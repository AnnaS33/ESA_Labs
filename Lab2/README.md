# Лабораторная 2

## Задание 1

В качестве модели использовалась модель из первой лабораторной (Manager, Model, Dress).

## Задание 2

Spring может за нас генерировать слой доступа к данным со всеми методами, которые мы будем использовать на сервисном слое. Для этого мы используем CrudRepository, который имеет набор базовых методов для работы с сущностью, и всё, что от нас нужно, это создать интерфейс без реализации, потому что реализацию Spring создаст автоматически.

И благодаря этому мы можем подставлять наши DAO-бины в полях сервлетов при помощи ```@Autowired```.

## Задание 3

Бизнес-уровень практически такой же, как и в первой лабораторной, но реализован с помощью Spring.

## Задание 4

Тоже практически такой же, что и для Java EE, но мы меняем аннотации Java EE на аннотации Spring.

Также в папке Webb есть небольшое веб-приложение, на котором можно посмотреть работу с таблицами, но там потребуется yarn. В следующих лабораторных будет использоваться Postman для просмотра ответов на запросы.

# Лабораторная 3

## Задание 1

Нами для разработки был выбран SpringREST. 

Каких-то сильных преимуществ или недостатков JAX-RC и SpringREST мы не нашли, а потому причины выбора довольно банальны:
1.	Раз уж мы работаем со Spring, то почему бы и не продолжить работать с ним.
2.	Работать c Java EE нам не понравилось, а JAX-RS - это спецификация Java EE, и вполне возможно, что опять возникнут какие-то сложности. 

## Задание 2

Это приложение разработано уже с учётом REST API.

## Задание 3

SpringREST позволять использовать как XML, так и JSON.

## Задания 4-5

Мы заменили один метод get, который возвращает все экземпляры сущности, на два. Первый обрабатывает запрос, если заголовок запроса ```Accept: application/xml```, а второй — если ```Accept: application/json```. Также мы можем отображать наши XML-объекты в виде HTML страницы: для этого были добавлены файлы *.xslt*.

Пример:

![image](https://user-images.githubusercontent.com/43893150/146374084-e30722d1-be29-4b96-b574-255184b3b731.png)

# Лабораторная работа 4

## Задание 1

Была добавлена новая таблица событий, где будут храниться записи, содержащие информацию о том, какие действия были совершены.

Таблица событий:

![image](https://user-images.githubusercontent.com/43893150/146374624-4e2b7039-3718-4eda-b011-c55ba3fe342d.png)

## Задания 2-6

Sender отвечает за получение информации об изменениях. Когда в сервлетах вызывается какой-то метод, он передаёт в Sender данные о том, в какой таблице произошли изменения, какой метод был вызван и какие данные были добавлены/удалены/обновлены. Sender их получает, создаёт объект *event* и отправляет его. 

Receiver — отвечает за обработку полученной информации и сохранение её в таблицах. С помощью аннотации ```@JmsListener``` мы указываем, что его метод — это конечная точка для слушателя JMS. Он ловит отправленные сообщения и записывает их в таблицу событий. А также создаёт объект *email*, в который записывает сообщение об изменении и электронную почту, на которую его надо отправить. И сохраняет в таблицу для уведомлений.

Таблица для уведомлений:

![image](https://user-images.githubusercontent.com/43893150/146374678-c5b74489-9c42-4ab9-bfc5-0bdbc30c3799.png)
